package com.gempukku.terasology.graphics.environment;

import com.badlogic.gdx.graphics.g3d.model.MeshPart;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Disposable;
import com.gempukku.terasology.world.chunk.ChunkLocation;

public class ChunkMesh implements ChunkLocation, Disposable {
    public enum Status {
        // Status when first created, before checking if mesh can be generated by generator
        NOT_READY,
        // Queue for generating mesh - set when we know it can be generated
        QUEUED_FOR_GENERATOR,
        // Set when an off-thread picks up the chunk to generate objects required
        GENERATING,
        // Set when an off-thread finishes to generate objects required
        GENERATED,
        // Set when the main thread generates the meshes
        READY,
        // Set when chunk is disposed
        DISPOSED;
    }

    public final String worldId;
    public final int x;
    public final int y;
    public final int z;

    private volatile Status status;

    private volatile Object generatorPreparedObject;
    private volatile Array<MeshPart> meshParts;

    public ChunkMesh(String worldId, int x, int y, int z) {
        this.worldId = worldId;
        this.x = x;
        this.y = y;
        this.z = z;
        status = Status.NOT_READY;
    }
//
//    public void processOffLine(ChunkMeshGenerator chunkMeshGenerator, List<Texture> textures) {
//        synchronized (this) {
//            if (!status.canOfflineProcess()) {
//                return;
//            }
//            status.setProcessingOffline();
//        }
//
//        Object preparedObject = chunkMeshGenerator.prepareChunkDataOffThread(textures, worldId, x, y, z);
//        synchronized (this) {
//            generatorPreparedObject = preparedObject;
//            status.setWaitingForModel();
//        }
//    }
//
//    public boolean updateModelIfNeeded(ChunkMeshGenerator chunkMeshGenerator) {
//        synchronized (this) {
//            if (status.isWaitingForMesh()) {
//                dispose();
//
//                synchronized (this) {
//                    meshParts = chunkMeshGenerator.generateMeshParts(generatorPreparedObject);
//
//                    generatorPreparedObject = null;
//                }
//                status.setHasMesh();
//                return true;
//            }
//        }
//        return false;
//    }
//
//    public void needsUpdate() {
//        synchronized (this) {
//            status.setNeedsOfflineProcessing();
//        }
//    }

    public Status getStatus() {
        return status;
    }

    public void setStatus(Status status) {
        this.status = status;
    }

    public Object getGeneratorPreparedObject() {
        return generatorPreparedObject;
    }

    public void setGeneratorPreparedObject(Object generatorPreparedObject) {
        this.generatorPreparedObject = generatorPreparedObject;
    }

    public void setMeshParts(Array<MeshPart> meshParts) {
        this.meshParts = meshParts;
    }

    public Array<MeshPart> getMeshParts() {
        return meshParts;
    }

    @Override
    public String getWorldId() {
        return worldId;
    }

    @Override
    public int getX() {
        return x;
    }

    @Override
    public int getY() {
        return y;
    }

    @Override
    public int getZ() {
        return z;
    }

    @Override
    public void dispose() {
        if (meshParts != null) {
            for (MeshPart meshPart : meshParts) {
                if (meshPart != null && meshPart.mesh != null) {
                    meshPart.mesh.dispose();
                }
            }
            meshParts = null;
        }
    }
}
